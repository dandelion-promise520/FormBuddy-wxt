var content=(function(){"use strict";function ae(o){return o}const V=globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome,F=V;var P=Object.prototype.hasOwnProperty;function C(o,e){var t,r;if(o===e)return!0;if(o&&e&&(t=o.constructor)===e.constructor){if(t===Date)return o.getTime()===e.getTime();if(t===RegExp)return o.toString()===e.toString();if(t===Array){if((r=o.length)===e.length)for(;r--&&C(o[r],e[r]););return r===-1}if(!t||typeof o=="object"){r=0;for(t in o)if(P.call(o,t)&&++r&&!P.call(e,t)||!(t in e)||!C(o[t],e[t]))return!1;return Object.keys(e).length===r}}return o!==o&&e!==e}const Y=new Error("request for lock canceled");var G=function(o,e,t,r){function u(l){return l instanceof t?l:new t(function(h){h(l)})}return new(t||(t=Promise))(function(l,h){function p(m){try{y(r.next(m))}catch(E){h(E)}}function S(m){try{y(r.throw(m))}catch(E){h(E)}}function y(m){m.done?l(m.value):u(m.value).then(p,S)}y((r=r.apply(o,e||[])).next())})};class Q{constructor(e,t=Y){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((r,u)=>{const l={resolve:r,reject:u,weight:e,priority:t},h=R(this._queue,p=>t<=p.priority);h===-1&&e<=this._value?this._dispatchItem(l):this._queue.splice(h+1,0,l)})}runExclusive(e){return G(this,arguments,void 0,function*(t,r=1,u=0){const[l,h]=yield this.acquire(r,u);try{return yield t(l)}finally{h()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(r=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),H(this._weightedWaiters[e-1],{resolve:r,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(r=>r.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const r=this._weightedWaiters[t-1];if(!r)continue;const u=r.findIndex(l=>l.priority<=e);(u===-1?r:r.splice(0,u)).forEach((l=>l.resolve()))}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function H(o,e){const t=R(o,r=>e.priority<=r.priority);o.splice(t+1,0,e)}function R(o,e){for(let t=o.length-1;t>=0;t--)if(e(o[t]))return t;return-1}var z=function(o,e,t,r){function u(l){return l instanceof t?l:new t(function(h){h(l)})}return new(t||(t=Promise))(function(l,h){function p(m){try{y(r.next(m))}catch(E){h(E)}}function S(m){try{y(r.throw(m))}catch(E){h(E)}}function y(m){m.done?l(m.value):u(m.value).then(p,S)}y((r=r.apply(o,e||[])).next())})};class B{constructor(e){this._semaphore=new Q(1,e)}acquire(){return z(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const J=X();function X(){const o={local:K("local"),session:K("session"),sync:K("sync"),managed:K("managed")},e=s=>{const a=o[s];if(a==null){const n=Object.keys(o).join(", ");throw Error(`Invalid area "${s}". Options: ${n}`)}return a},t=s=>{const a=s.indexOf(":"),n=s.substring(0,a),i=s.substring(a+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${s}"`);return{driverArea:n,driverKey:i,driver:e(n)}},r=s=>s+"$",u=(s,a)=>{const n={...s};return Object.entries(a).forEach(([i,c])=>{c==null?delete n[i]:n[i]=c}),n},l=(s,a)=>s??a??null,h=s=>typeof s=="object"&&!Array.isArray(s)?s:{},p=async(s,a,n)=>{const i=await s.getItem(a);return l(i,n?.fallback??n?.defaultValue)},S=async(s,a)=>{const n=r(a),i=await s.getItem(n);return h(i)},y=async(s,a,n)=>{await s.setItem(a,n??null)},m=async(s,a,n)=>{const i=r(a),c=h(await s.getItem(i));await s.setItem(i,u(c,n))},E=async(s,a,n)=>{if(await s.removeItem(a),n?.removeMeta){const i=r(a);await s.removeItem(i)}},U=async(s,a,n)=>{const i=r(a);if(n==null)await s.removeItem(i);else{const c=h(await s.getItem(i));[n].flat().forEach(d=>delete c[d]),await s.setItem(i,c)}},W=(s,a,n)=>s.watch(a,n);return{getItem:async(s,a)=>{const{driver:n,driverKey:i}=t(s);return await p(n,i,a)},getItems:async s=>{const a=new Map,n=new Map,i=[];s.forEach(d=>{let w,v;typeof d=="string"?w=d:"getValue"in d?(w=d.key,v={fallback:d.fallback}):(w=d.key,v=d.options),i.push(w);const{driverArea:I,driverKey:f}=t(w),_=a.get(I)??[];a.set(I,_.concat(f)),n.set(w,v)});const c=new Map;return await Promise.all(Array.from(a.entries()).map(async([d,w])=>{(await o[d].getItems(w)).forEach(I=>{const f=`${d}:${I.key}`,_=n.get(f),b=l(I.value,_?.fallback??_?.defaultValue);c.set(f,b)})})),i.map(d=>({key:d,value:c.get(d)}))},getMeta:async s=>{const{driver:a,driverKey:n}=t(s);return await S(a,n)},getMetas:async s=>{const a=s.map(c=>{const d=typeof c=="string"?c:c.key,{driverArea:w,driverKey:v}=t(d);return{key:d,driverArea:w,driverKey:v,driverMetaKey:r(v)}}),n=a.reduce((c,d)=>(c[d.driverArea]??=[],c[d.driverArea].push(d),c),{}),i={};return await Promise.all(Object.entries(n).map(async([c,d])=>{const w=await V.storage[c].get(d.map(v=>v.driverMetaKey));d.forEach(v=>{i[v.key]=w[v.driverMetaKey]??{}})})),a.map(c=>({key:c.key,meta:i[c.key]}))},setItem:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await y(n,i,a)},setItems:async s=>{const a={};s.forEach(n=>{const{driverArea:i,driverKey:c}=t("key"in n?n.key:n.item.key);a[i]??=[],a[i].push({key:c,value:n.value})}),await Promise.all(Object.entries(a).map(async([n,i])=>{await e(n).setItems(i)}))},setMeta:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await m(n,i,a)},setMetas:async s=>{const a={};s.forEach(n=>{const{driverArea:i,driverKey:c}=t("key"in n?n.key:n.item.key);a[i]??=[],a[i].push({key:c,properties:n.meta})}),await Promise.all(Object.entries(a).map(async([n,i])=>{const c=e(n),d=i.map(({key:f})=>r(f)),w=await c.getItems(d),v=Object.fromEntries(w.map(({key:f,value:_})=>[f,h(_)])),I=i.map(({key:f,properties:_})=>{const b=r(f);return{key:b,value:u(v[b]??{},_)}});await c.setItems(I)}))},removeItem:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await E(n,i,a)},removeItems:async s=>{const a={};s.forEach(n=>{let i,c;typeof n=="string"?i=n:"getValue"in n?i=n.key:"item"in n?(i=n.item.key,c=n.options):(i=n.key,c=n.options);const{driverArea:d,driverKey:w}=t(i);a[d]??=[],a[d].push(w),c?.removeMeta&&a[d].push(r(w))}),await Promise.all(Object.entries(a).map(async([n,i])=>{await e(n).removeItems(i)}))},clear:async s=>{await e(s).clear()},removeMeta:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await U(n,i,a)},snapshot:async(s,a)=>{const i=await e(s).snapshot();return a?.excludeKeys?.forEach(c=>{delete i[c],delete i[r(c)]}),i},restoreSnapshot:async(s,a)=>{await e(s).restoreSnapshot(a)},watch:(s,a)=>{const{driver:n,driverKey:i}=t(s);return W(n,i,a)},unwatch(){Object.values(o).forEach(s=>{s.unwatch()})},defineItem:(s,a)=>{const{driver:n,driverKey:i}=t(s),{version:c=1,migrations:d={},onMigrationComplete:w,debug:v=!1}=a??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const I=async()=>{const g=r(i),[{value:M},{value:q}]=await n.getItems([i,g]);if(M==null)return;const x=q?.v??1;if(x>c)throw Error(`Version downgrade detected (v${x} -> v${c}) for "${s}"`);if(x===c)return;v===!0&&console.debug(`[@wxt-dev/storage] Running storage migration for ${s}: v${x} -> v${c}`);const se=Array.from({length:c-x},(L,j)=>x+j+1);let T=M;for(const L of se)try{T=await d?.[L]?.(T)??T,v===!0&&console.debug(`[@wxt-dev/storage] Storage migration processed for version: v${L}`)}catch(j){throw new Z(s,L,{cause:j})}await n.setItems([{key:i,value:T},{key:g,value:{...q,v:c}}]),v===!0&&console.debug(`[@wxt-dev/storage] Storage migration completed for ${s} v${c}`,{migratedValue:T}),w?.(T,c)},f=a?.migrations==null?Promise.resolve():I().catch(g=>{console.error(`[@wxt-dev/storage] Migration failed for ${s}`,g)}),_=new B,b=()=>a?.fallback??a?.defaultValue??null,D=()=>_.runExclusive(async()=>{const g=await n.getItem(i);if(g!=null||a?.init==null)return g;const M=await a.init();return await n.setItem(i,M),M});return f.then(D),{key:s,get defaultValue(){return b()},get fallback(){return b()},getValue:async()=>(await f,a?.init?await D():await p(n,i,a)),getMeta:async()=>(await f,await S(n,i)),setValue:async g=>(await f,await y(n,i,g)),setMeta:async g=>(await f,await m(n,i,g)),removeValue:async g=>(await f,await E(n,i,g)),removeMeta:async g=>(await f,await U(n,i,g)),watch:g=>W(n,i,(M,q)=>g(M??b(),q??b())),migrate:I}}}}function K(o){const e=()=>{if(V.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(V.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const r=V.storage[o];if(r==null)throw Error(`"browser.storage.${o}" is undefined`);return r},t=new Set;return{getItem:async r=>(await e().get(r))[r],getItems:async r=>{const u=await e().get(r);return r.map(l=>({key:l,value:u[l]??null}))},setItem:async(r,u)=>{u==null?await e().remove(r):await e().set({[r]:u})},setItems:async r=>{const u=r.reduce((l,{key:h,value:p})=>(l[h]=p,l),{});await e().set(u)},removeItem:async r=>{await e().remove(r)},removeItems:async r=>{await e().remove(r)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async r=>{await e().set(r)},watch(r,u){const l=h=>{const p=h[r];p!=null&&(C(p.newValue,p.oldValue)||u(p.newValue??null,p.oldValue??null))};return e().onChanged.addListener(l),t.add(l),()=>{e().onChanged.removeListener(l),t.delete(l)}},unwatch(){t.forEach(r=>{e().onChanged.removeListener(r)}),t.clear()}}}class Z extends Error{constructor(e,t,r){super(`v${t} migration failed for "${e}"`,r),this.key=e,this.version=t}}const ee={matches:["<all_urls>"],main(){const o=t=>{const r=document.activeElement;if(!(r instanceof HTMLInputElement||r instanceof HTMLTextAreaElement))throw new Error("当前页面没有您选中的元素");r.value=t,r.dispatchEvent(new Event("input",{bubbles:!0}))};F.runtime.onMessage.addListener((t,r,u)=>(console.log("收到来自popup的消息",t),o(t),u({success:!0,data:"content响应数据"}),!0));const e=J.defineItem("local:userInfos");window.addEventListener("keydown",async t=>{if(t.altKey&&t.key!=="Alt"){const r=await e.getValue();if(!r)throw new Error("用户数据不存在");if(+t.key>r.length)throw new Error("您按下的键值没有找到对应您设置的信息");o(r[+t.key-1].value)}})}};function $(o,...e){}const te={debug:(...o)=>$(console.debug,...o),log:(...o)=>$(console.log,...o),warn:(...o)=>$(console.warn,...o),error:(...o)=>$(console.error,...o)};class O extends Event{constructor(e,t){super(O.EVENT_NAME,{}),this.newUrl=e,this.oldUrl=t}static EVENT_NAME=N("wxt:locationchange")}function N(o){return`${F?.runtime?.id}:content:${o}`}function re(o){let e,t;return{run(){e==null&&(t=new URL(location.href),e=o.setInterval(()=>{let r=new URL(location.href);r.href!==t.href&&(window.dispatchEvent(new O(r,t)),t=r)},1e3))}}}class k{constructor(e,t){this.contentScriptName=e,this.options=t,this.abortController=new AbortController,this.isTopFrame?(this.listenForNewerScripts({ignoreFirstEvent:!0}),this.stopOldScripts()):this.listenForNewerScripts()}static SCRIPT_STARTED_MESSAGE_TYPE=N("wxt:content-script-started");isTopFrame=window.self===window.top;abortController;locationWatcher=re(this);receivedMessageIds=new Set;get signal(){return this.abortController.signal}abort(e){return this.abortController.abort(e)}get isInvalid(){return F.runtime.id==null&&this.notifyInvalidated(),this.signal.aborted}get isValid(){return!this.isInvalid}onInvalidated(e){return this.signal.addEventListener("abort",e),()=>this.signal.removeEventListener("abort",e)}block(){return new Promise(()=>{})}setInterval(e,t){const r=setInterval(()=>{this.isValid&&e()},t);return this.onInvalidated(()=>clearInterval(r)),r}setTimeout(e,t){const r=setTimeout(()=>{this.isValid&&e()},t);return this.onInvalidated(()=>clearTimeout(r)),r}requestAnimationFrame(e){const t=requestAnimationFrame((...r)=>{this.isValid&&e(...r)});return this.onInvalidated(()=>cancelAnimationFrame(t)),t}requestIdleCallback(e,t){const r=requestIdleCallback((...u)=>{this.signal.aborted||e(...u)},t);return this.onInvalidated(()=>cancelIdleCallback(r)),r}addEventListener(e,t,r,u){t==="wxt:locationchange"&&this.isValid&&this.locationWatcher.run(),e.addEventListener?.(t.startsWith("wxt:")?N(t):t,r,{...u,signal:this.signal})}notifyInvalidated(){this.abort("Content script context invalidated"),te.debug(`Content script "${this.contentScriptName}" context invalidated`)}stopOldScripts(){window.postMessage({type:k.SCRIPT_STARTED_MESSAGE_TYPE,contentScriptName:this.contentScriptName,messageId:Math.random().toString(36).slice(2)},"*")}verifyScriptStartedEvent(e){const t=e.data?.type===k.SCRIPT_STARTED_MESSAGE_TYPE,r=e.data?.contentScriptName===this.contentScriptName,u=!this.receivedMessageIds.has(e.data?.messageId);return t&&r&&u}listenForNewerScripts(e){let t=!0;const r=u=>{if(this.verifyScriptStartedEvent(u)){this.receivedMessageIds.add(u.data.messageId);const l=t;if(t=!1,l&&e?.ignoreFirstEvent)return;this.notifyInvalidated()}};addEventListener("message",r),this.onInvalidated(()=>removeEventListener("message",r))}}function ie(){}function A(o,...e){}const ne={debug:(...o)=>A(console.debug,...o),log:(...o)=>A(console.log,...o),warn:(...o)=>A(console.warn,...o),error:(...o)=>A(console.error,...o)};return(async()=>{try{const{main:o,...e}=ee,t=new k("content",e);return await o(t)}catch(o){throw ne.error('The content script "content" crashed on startup!',o),o}})()})();
content;